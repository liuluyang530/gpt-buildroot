--- libffi-3.3/Makefile.am	2020-03-23 20:08:19.351379145 +0800
+++ libffi-3.3-back/Makefile.am	2020-03-23 20:05:15.397732729 +0800
@@ -53,6 +53,7 @@
 	src/bfin/ffitarget.h						\
 	src/cris/ffitarget.h						\
 	src/frv/ffitarget.h						\
+	src/gptx/ffitarget.h						\
 	src/ia64/ffitarget.h src/ia64/ia64_flags.h			\
 	src/m32r/ffitarget.h						\
 	src/m68k/ffitarget.h						\
@@ -82,6 +83,7 @@
 	src/arm/sysv.S src/arm/ffi.c src/arm/sysv_msvc_arm32.S \
 	src/avr32/ffi.c src/avr32/sysv.S src/bfin/ffi.c	\
 	src/bfin/sysv.S src/cris/ffi.c src/cris/sysv.S src/frv/ffi.c \
+	src/gptx/ffi.c src/gptx/sysv.S \
 	src/frv/eabi.S src/ia64/ffi.c src/ia64/unix.S src/m32r/ffi.c \
 	src/m32r/sysv.S src/m68k/ffi.c src/m68k/sysv.S src/m88k/ffi.c \
 	src/m88k/obsd.S src/metag/ffi.c src/metag/sysv.S \

--- libffi-3.3/configure.host	2019-11-23 23:24:58.000000000 +0800
+++ libffi-3.3-back/configure.host	2020-03-23 20:06:44.442697048 +0800
@@ -58,6 +58,11 @@
 	SOURCES="ffi.c eabi.S"
 	;;
 
+  polaris-gpt-*-* |  gptx-*-*)
+	TARGET=GPTX; TARGETDIR=gptx
+	SOURCES="ffi.c sysv.S"
+	;;
+	
   hppa*-*-linux* | parisc*-*-linux* | hppa*-*-openbsd*)
 	TARGET=PA_LINUX; TARGETDIR=pa
 	SOURCES="ffi.c linux.S"

diff -Nura output/build/libffi-3.2.1-old/src/gptx/ffi.c output/build/libffi-3.2.1/src/gptx/ffi.c
--- a/src/gptx/ffi.c	1970-01-01 08:00:00.000000000 +0800
+++ b/src/gptx/ffi.c	2019-02-21 17:38:06.000000000 +0800
@@ -0,0 +1,1128 @@
+/* Copyright (c) 2009, 2010, 2011, 2012 ARM Ltd.
+
+Permission is hereby granted, free of charge, to any person obtaining
+a copy of this software and associated documentation files (the
+``Software''), to deal in the Software without restriction, including
+without limitation the rights to use, copy, modify, merge, publish,
+distribute, sublicense, and/or sell copies of the Software, and to
+permit persons to whom the Software is furnished to do so, subject to
+the following conditions:
+
+The above copyright notice and this permission notice shall be
+included in all copies or substantial portions of the Software.
+
+THE SOFTWARE IS PROVIDED ``AS IS'', WITHOUT WARRANTY OF ANY KIND,
+EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
+MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.
+IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY
+CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT,
+TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE
+SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.  */
+
+#include <stdio.h>
+
+#include <ffi.h>
+#include <ffi_common.h>
+
+#include <stdlib.h>
+
+/* Stack alignment requirement in bytes */
+#define GPTX_STACK_ALIGN 8
+
+#define N_R_ARG_REG 8
+#define N_F_ARG_REG 8
+
+#define GPTX_FFI_WITH_R (1 << GPTX_FFI_WITH_R_BIT)
+
+struct call_context
+{
+  UINT64 r [GPTX_N_RREG];
+  UINT64 f [GPTX_N_FREG];
+};
+
+static inline void
+ffi_clear_cache (void *start, void *end)
+{
+#if defined (__GNUC__)
+	__builtin___clear_cache (start, end);
+#else
+#error "Missing builtin to flush instruction cache"
+#endif
+}
+
+static void *
+get_r_addr (struct call_context *context, unsigned n)
+{
+  return &context->r[n];
+}
+
+static void *
+get_f_addr (struct call_context *context, unsigned n)
+{
+  return &context->f[n];
+}
+
+/* Return the memory location at which a basic type would reside
+   were it to have been stored in register n.  */
+
+static void *
+get_basic_type_addr (unsigned short type, struct call_context *context,
+		     unsigned n)
+{
+  switch (type)
+    {
+    case FFI_TYPE_FLOAT:
+    case FFI_TYPE_DOUBLE:
+      return get_f_addr (context, n);
+#if FFI_TYPE_DOUBLE != FFI_TYPE_LONGDOUBLE
+    case FFI_TYPE_LONGDOUBLE:
+      return get_f_addr (context, n * 2);
+#endif
+    case FFI_TYPE_UINT8:
+    case FFI_TYPE_SINT8:
+    case FFI_TYPE_UINT16:
+    case FFI_TYPE_SINT16:
+    case FFI_TYPE_UINT32:
+    case FFI_TYPE_SINT32:
+    case FFI_TYPE_INT:
+    case FFI_TYPE_POINTER:
+    case FFI_TYPE_UINT64:
+    case FFI_TYPE_SINT64:
+      return get_r_addr (context, n);
+    case FFI_TYPE_VOID:
+      return NULL;
+    default:
+      FFI_ASSERT (0);
+      return NULL;
+    }
+}
+
+/* Return the alignment width for each of the basic types.  */
+
+static size_t
+get_basic_type_alignment (unsigned short type)
+{
+  switch (type)
+    {
+    case FFI_TYPE_FLOAT:
+    case FFI_TYPE_DOUBLE:
+      return sizeof (UINT64);
+#if FFI_TYPE_DOUBLE != FFI_TYPE_LONGDOUBLE
+    case FFI_TYPE_LONGDOUBLE:
+      return sizeof (UINT64);
+      //return sizeof (long double);
+#endif
+    case FFI_TYPE_UINT8:
+    case FFI_TYPE_SINT8:
+    case FFI_TYPE_UINT16:
+    case FFI_TYPE_SINT16:
+    case FFI_TYPE_UINT32:
+    case FFI_TYPE_INT:
+    case FFI_TYPE_SINT32:
+    case FFI_TYPE_POINTER:
+    case FFI_TYPE_UINT64:
+    case FFI_TYPE_SINT64:
+      return sizeof (UINT64);
+
+    default:
+      FFI_ASSERT (0);
+      return 0;
+    }
+}
+
+/* Return the size in bytes for each of the basic types.  */
+
+static size_t
+get_basic_type_size (unsigned short type)
+{
+  switch (type)
+    {
+    case FFI_TYPE_FLOAT:
+      return sizeof (float);
+    case FFI_TYPE_DOUBLE:
+      return sizeof (UINT64);
+#if FFI_TYPE_DOUBLE != FFI_TYPE_LONGDOUBLE
+    case FFI_TYPE_LONGDOUBLE:
+      return sizeof (long double);
+#endif
+    case FFI_TYPE_UINT8:
+      return sizeof (UINT8);
+    case FFI_TYPE_SINT8:
+      return sizeof (SINT8);
+    case FFI_TYPE_UINT16:
+      return sizeof (UINT16);
+    case FFI_TYPE_SINT16:
+      return sizeof (SINT16);
+    case FFI_TYPE_UINT32:
+      return sizeof (UINT32);
+    case FFI_TYPE_INT:
+    case FFI_TYPE_SINT32:
+      return sizeof (SINT32);
+    case FFI_TYPE_POINTER:
+    case FFI_TYPE_UINT64:
+      return sizeof (UINT64);
+    case FFI_TYPE_SINT64:
+      return sizeof (SINT64);
+
+    default:
+      FFI_ASSERT (0);
+      return 0;
+    }
+}
+
+extern void
+ffi_call_SYSV (unsigned (*)(struct call_context *context, unsigned char *,
+			    extended_cif *),
+               struct call_context *context,
+               extended_cif *,
+               size_t,
+               void (*fn)(void));
+
+extern void
+ffi_closure_SYSV (ffi_closure *);
+
+/* Test for an FFI floating point representation.  */
+
+static unsigned
+is_floating_type (unsigned short type)
+{
+  return (type == FFI_TYPE_FLOAT || type == FFI_TYPE_DOUBLE
+	  || type == FFI_TYPE_LONGDOUBLE);
+}
+
+/* Test for a homogeneous structure.  */
+
+static unsigned short
+get_homogeneous_type (ffi_type *ty)
+{
+  if (ty->type == FFI_TYPE_STRUCT && ty->elements)
+    {
+      unsigned i;
+      unsigned short candidate_type
+	= get_homogeneous_type (ty->elements[0]);
+      for (i =1; ty->elements[i]; i++)
+	{
+	  unsigned short iteration_type = 0;
+	  /* If we have a nested struct, we must find its homogeneous type.
+	     If that fits with our candidate type, we are still
+	     homogeneous.  */
+	  if (ty->elements[i]->type == FFI_TYPE_STRUCT
+	      && ty->elements[i]->elements)
+	    {
+	      iteration_type = get_homogeneous_type (ty->elements[i]);
+	    }
+	  else
+	    {
+	      iteration_type = ty->elements[i]->type;
+	    }
+
+	  /* If we are not homogeneous, return FFI_TYPE_STRUCT.  */
+	  if (candidate_type != iteration_type)
+	    return FFI_TYPE_STRUCT;
+	}
+      return candidate_type;
+    }
+
+  /* Base case, we have no more levels of nesting, so we
+     are a basic type, and so, trivially homogeneous in that type.  */
+  return ty->type;
+}
+
+/* Determine the number of elements within a STRUCT.
+
+   Note, we must handle nested structs.
+
+   If ty is not a STRUCT this function will return 0.  */
+
+static unsigned
+element_count (ffi_type *ty)
+{
+  if (ty->type == FFI_TYPE_STRUCT && ty->elements)
+    {
+      unsigned n;
+      unsigned elems = 0;
+      for (n = 0; ty->elements[n]; n++)
+	{
+	  if (ty->elements[n]->type == FFI_TYPE_STRUCT
+	      && ty->elements[n]->elements)
+	    elems += element_count (ty->elements[n]);
+	  else
+	    elems++;
+	}
+      return elems;
+    }
+  return 0;
+}
+
+/* Test for a homogeneous floating point aggregate.
+
+   A homogeneous floating point aggregate is a homogeneous aggregate of
+   a half- single- or double- precision floating point type with one
+   to four elements.  Note that this includes nested structs of the
+   basic type.  */
+
+static int
+is_hfa (ffi_type *ty)
+{
+  if (ty->type == FFI_TYPE_STRUCT
+      && ty->elements[0]
+      && is_floating_type (get_homogeneous_type (ty)))
+    {
+      unsigned n = element_count (ty);
+      return n >= 1 && n <= 4;
+    }
+  return 0;
+}
+
+/* Test if an ffi_type is a candidate for passing in a register.
+
+   This test does not check that sufficient registers of the
+   appropriate class are actually available, merely that IFF
+   sufficient registers are available then the argument will be passed
+   in register(s).
+
+   Note that an ffi_type that is deemed to be a register candidate
+   will always be returned in registers.
+
+   Returns 1 if a register candidate else 0.  */
+
+static int
+is_register_candidate (ffi_type *ty)
+{
+  switch (ty->type)
+    {
+    case FFI_TYPE_VOID:
+    case FFI_TYPE_FLOAT:
+    case FFI_TYPE_DOUBLE:
+#if FFI_TYPE_DOUBLE != FFI_TYPE_LONGDOUBLE
+    case FFI_TYPE_LONGDOUBLE:
+#endif
+    case FFI_TYPE_UINT8:
+    case FFI_TYPE_UINT16:
+    case FFI_TYPE_UINT32:
+    case FFI_TYPE_UINT64:
+    case FFI_TYPE_POINTER:
+    case FFI_TYPE_SINT8:
+    case FFI_TYPE_SINT16:
+    case FFI_TYPE_SINT32:
+    case FFI_TYPE_INT:
+    case FFI_TYPE_SINT64:
+      return 1;
+
+    case FFI_TYPE_STRUCT:
+      if (is_hfa (ty))
+        {
+          return 1;
+        }
+      else if (ty->size > 16)
+        {
+          /* Too large. Will be replaced with a pointer to memory. The
+             pointer MAY be passed in a register, but the value will
+             not. This test specifically fails since the argument will
+             never be passed by value in registers. */
+          return 0;
+        }
+      else
+        {
+          /* Might be passed in registers depending on the number of
+             registers required. */
+          return (ty->size + 7) / 8 < N_R_ARG_REG;
+        }
+      break;
+
+    default:
+      FFI_ASSERT (0);
+      break;
+    }
+
+  return 0;
+}
+
+/* Test if an ffi_type argument or result is a candidate for a vector
+   register.  */
+
+static int
+is_f_register_candidate (ffi_type *ty)
+{
+  return is_floating_type (ty->type)
+	   || (ty->type == FFI_TYPE_STRUCT && is_hfa (ty));
+}
+
+/* Representation of the procedure call argument marshalling
+   state. */
+
+struct arg_state
+{
+  unsigned ngrn;                /* Next general-purpose register number. */
+  unsigned nfrn;                /* Next floating point register number. */
+  size_t nsaa;                  /* Next stack offset. */
+};
+
+/* Initialize a procedure call argument marshalling state.  */
+static void
+arg_init (struct arg_state *state, size_t call_frame_size)
+{
+  state->ngrn = 0;
+  state->nfrn = 0;
+  state->nsaa = 0;
+}
+
+/* Return the number of available consecutive core argument
+   registers.  */
+
+static unsigned
+available_r (struct arg_state *state)
+{
+  return N_R_ARG_REG - state->ngrn;
+}
+
+/* Return the number of available consecutive vector argument
+   registers.  */
+
+static unsigned
+available_f (struct arg_state *state)
+{
+  return N_F_ARG_REG - state->nfrn;
+}
+
+static void *
+allocate_to_r (struct call_context *context, struct arg_state *state)
+{
+  FFI_ASSERT (state->ngrn < N_R_ARG_REG);
+  return get_r_addr (context, (state->ngrn)++);
+}
+
+static void *
+allocate_to_f (struct call_context *context, struct arg_state *state)
+{
+  FFI_ASSERT (state->nfrn < N_F_ARG_REG);
+  return get_f_addr (context, (state->nfrn)++);
+}
+
+static void *
+allocate_to_ld (struct call_context *context, struct arg_state *state)
+{
+  FFI_ASSERT (state->nfrn + 1 < N_F_ARG_REG);
+  state->nfrn += 2;
+  return get_f_addr (context, (state->nfrn - 2));
+}
+
+/* Allocate an aligned slot on the stack and return a pointer to it.  */
+static void *
+allocate_to_stack (struct arg_state *state, void *stack, size_t alignment,
+		   size_t size)
+{
+  void *allocation;
+
+  /* Round up the NSAA to the larger of 8 or the natural
+     alignment of the argument's type.  */
+  state->nsaa = ALIGN (state->nsaa, alignment);
+  state->nsaa = ALIGN (state->nsaa, 8);
+
+  allocation = stack + state->nsaa;
+
+  state->nsaa += size;
+  return allocation;
+}
+
+static void
+copy_basic_type (void *dest, void *source, unsigned short type, int in_stack)
+{
+  /* This is necessary to ensure that basic types are copied
+     sign extended to 64-bits as libffi expects.  */
+  switch (type)
+    {
+    case FFI_TYPE_FLOAT:
+      //*(float *) dest = *(float *) source;
+      if (!in_stack)
+        __asm__ volatile (
+          "\tldfs\t$f8, %1\n\tstf\t$f8,%0\n"
+          : "=m"(*(double *)dest)
+          : "m"(*(float *)source) : "memory", "$f8");
+      else
+        *(float *) dest = *(float *) source;
+      break;
+    case FFI_TYPE_DOUBLE:
+      *(double *) dest = *(double *) source;
+      break;
+#if FFI_TYPE_DOUBLE != FFI_TYPE_LONGDOUBLE
+    case FFI_TYPE_LONGDOUBLE:
+      *(long double *) dest = *(long double *) source;
+      break;
+#endif
+    case FFI_TYPE_UINT8:
+      *(ffi_arg *) dest = *(UINT8 *) source;
+      break;
+    case FFI_TYPE_SINT8:
+      *(ffi_sarg *) dest = *(SINT8 *) source;
+      break;
+    case FFI_TYPE_UINT16:
+      *(ffi_arg *) dest = *(UINT16 *) source;
+      break;
+    case FFI_TYPE_SINT16:
+      *(ffi_sarg *) dest = *(SINT16 *) source;
+      break;
+    case FFI_TYPE_UINT32:
+      *(ffi_arg *) dest = *(UINT32 *) source;
+      break;
+    case FFI_TYPE_INT:
+    case FFI_TYPE_SINT32:
+      *(ffi_sarg *) dest = *(SINT32 *) source;
+      break;
+    case FFI_TYPE_POINTER:
+    case FFI_TYPE_UINT64:
+      *(ffi_arg *) dest = *(UINT64 *) source;
+      break;
+    case FFI_TYPE_SINT64:
+      *(ffi_sarg *) dest = *(SINT64 *) source;
+      break;
+    case FFI_TYPE_VOID:
+      break;
+
+    default:
+      FFI_ASSERT (0);
+    }
+}
+
+static void
+copy_float_type_back (void *dest, void *source)
+{
+  __asm__ volatile (
+    "\tldf\t$f8, %1\n\tstfs\t$f8,%0\n"
+    : "=m"(*(float *)dest)
+    : "m"(*(double *)source) : "memory", "$f8");
+}
+
+static void
+copy_hfa_to_reg_or_stack (void *memory,
+			  ffi_type *ty,
+			  struct call_context *context,
+			  unsigned char *stack,
+			  struct arg_state *state)
+{
+  unsigned elems = element_count (ty);
+  unsigned short type = get_homogeneous_type (ty); 
+  if (available_f (state) < (elems << (type == FFI_TYPE_LONGDOUBLE)))
+    {
+      /* There are insufficient V registers. Further V register allocations
+	 are prevented, the NSAA is adjusted (by allocate_to_stack ())
+	 and the argument is copied to memory at the adjusted NSAA.  */
+      state->nfrn = N_F_ARG_REG;
+      memcpy (allocate_to_stack (state, stack, ty->alignment, ty->size),
+	      memory,
+	      ty->size);
+    }
+  else
+    {
+      int i;
+      for (i = 0; i < elems; i++)
+	{
+	  void *reg = 
+            type == FFI_TYPE_LONGDOUBLE ?
+	      allocate_to_ld (context, state) :
+	      allocate_to_f (context, state);
+	  copy_basic_type (reg, memory, type, 0);
+	  memory += get_basic_type_size (type);
+	}
+    }
+}
+
+/* Either allocate an appropriate register for the argument type, or if
+   none are available, allocate a stack slot and return a pointer
+   to the allocated space.  */
+
+static void *
+allocate_to_register_or_stack (struct call_context *context,
+			       unsigned char *stack,
+			       struct arg_state *state,
+			       unsigned short type,
+			       int *in_stack)
+{
+  size_t alignment = get_basic_type_alignment (type);
+  size_t size = alignment;
+  *in_stack = 0;
+  switch (type)
+    {
+    case FFI_TYPE_FLOAT:
+      /* This is the only case for which the allocated stack size
+	 should not match the alignment of the type.  */
+      size = sizeof (UINT32);
+      /* Fall through.  */
+    case FFI_TYPE_DOUBLE:
+      if (state->nfrn < N_F_ARG_REG)
+	return allocate_to_f (context, state);
+      state->nfrn = N_F_ARG_REG;
+      break;
+#if FFI_TYPE_DOUBLE != FFI_TYPE_LONGDOUBLE
+    case FFI_TYPE_LONGDOUBLE:
+      size = sizeof (long double);
+      if (state->nfrn + 1 < N_F_ARG_REG)
+	return allocate_to_ld (context, state);
+      state->nfrn = N_F_ARG_REG;
+      break;
+#endif
+    case FFI_TYPE_UINT8:
+    case FFI_TYPE_SINT8:
+    case FFI_TYPE_UINT16:
+    case FFI_TYPE_SINT16:
+    case FFI_TYPE_UINT32:
+    case FFI_TYPE_SINT32:
+    case FFI_TYPE_INT:
+    case FFI_TYPE_POINTER:
+    case FFI_TYPE_UINT64:
+    case FFI_TYPE_SINT64:
+      if (state->ngrn < N_R_ARG_REG)
+	return allocate_to_r (context, state);
+      state->ngrn = N_R_ARG_REG;
+      break;
+    default:
+      FFI_ASSERT (0);
+    }
+    *in_stack = 1;
+    return allocate_to_stack (state, stack, alignment, size);
+}
+
+/* Copy a value to an appropriate register, or if none are
+   available, to the stack.  */
+
+static void
+copy_to_register_or_stack (struct call_context *context,
+			   unsigned char *stack,
+			   struct arg_state *state,
+			   void *value,
+			   unsigned short type)
+{
+  int in_stack;
+  copy_basic_type (
+	  allocate_to_register_or_stack (context, stack, state, type, &in_stack),
+	  value,
+	  type,
+	  in_stack);
+}
+
+/* Marshall the arguments from FFI representation to procedure call
+   context and stack.  */
+
+static unsigned
+gptx_prep_args (struct call_context *context, unsigned char *stack,
+		extended_cif *ecif)
+{
+  int i;
+  struct arg_state state;
+
+  arg_init (&state, ALIGN(ecif->cif->bytes, 16));
+
+  if (!is_register_candidate (ecif->cif->rtype))
+    state.ngrn++;
+  for (i = 0; i < ecif->cif->nargs; i++)
+    {
+      ffi_type *ty = ecif->cif->arg_types[i];
+      switch (ty->type)
+	{
+	case FFI_TYPE_VOID:
+	  FFI_ASSERT (0);
+	  break;
+
+	/* If the argument is a basic type the argument is allocated to an
+	   appropriate register, or if none are available, to the stack.  */
+	case FFI_TYPE_FLOAT:
+	case FFI_TYPE_DOUBLE:
+#if FFI_TYPE_DOUBLE != FFI_TYPE_LONGDOUBLE
+	case FFI_TYPE_LONGDOUBLE:
+#endif
+	case FFI_TYPE_UINT8:
+	case FFI_TYPE_SINT8:
+	case FFI_TYPE_UINT16:
+	case FFI_TYPE_SINT16:
+	case FFI_TYPE_UINT32:
+	case FFI_TYPE_INT:
+	case FFI_TYPE_SINT32:
+	case FFI_TYPE_POINTER:
+	case FFI_TYPE_UINT64:
+	case FFI_TYPE_SINT64:
+	  copy_to_register_or_stack (context, stack, &state,
+				     ecif->avalue[i], ty->type);
+	  break;
+
+	case FFI_TYPE_STRUCT:
+	  if (is_hfa (ty))
+	    {
+	      copy_hfa_to_reg_or_stack (ecif->avalue[i], ty, context,
+					stack, &state);
+	    }
+	  else if (ty->size > 16)
+	    {
+	      /* If the argument is a composite type that is larger than 16
+		 bytes, then the argument has been copied to memory, and
+		 the argument is replaced by a pointer to the copy.  */
+
+	      copy_to_register_or_stack (context, stack, &state,
+					 &(ecif->avalue[i]), FFI_TYPE_POINTER);
+	    }
+	  else if (available_r (&state) >= (ty->size + 7) / 8)
+	    {
+	      /* If the argument is a composite type and the size in
+		 double-words is not more than the number of available
+		 R registers, then the argument is copied into consecutive
+		 R registers.  */
+	      int j;
+	      for (j = 0; j < (ty->size + 7) / 8; j++)
+		{
+		  memcpy (allocate_to_r (context, &state),
+			  &(((UINT64 *) ecif->avalue[i])[j]),
+			  sizeof (UINT64));
+		}
+	    }
+	  else
+	    {
+	      /* Otherwise, there are insufficient R registers. Further R
+		 register allocations are prevented, the NSAA is adjusted
+		 (by allocate_to_stack ()) and the argument is copied to
+		 memory at the adjusted NSAA.  */
+	      state.ngrn = N_R_ARG_REG;
+
+	      memcpy (allocate_to_stack (&state, stack, ty->alignment,
+					 ty->size), ((UINT64 *) ecif->avalue[i]), ty->size);
+	    }
+	  break;
+
+	default:
+	  FFI_ASSERT (0);
+	  break;
+	}
+
+    }
+
+  return ecif->cif->gptx_flags;
+}
+
+ffi_status
+ffi_prep_cif_machdep (ffi_cif *cif)
+{
+  /* Round the stack up to a multiple of the stack alignment requirement. */
+  cif->bytes =
+    (cif->bytes + (GPTX_STACK_ALIGN - 1)) & ~ (GPTX_STACK_ALIGN - 1);
+
+  /* Initialize our flags. We are interested if this CIF will touch a
+     vector register, if so we will enable context save and load to
+     those registers, otherwise not. This is intended to be friendly
+     to lazy float context switching in the kernel.  */
+  cif->gptx_flags = 0;
+
+  if (is_f_register_candidate (cif->rtype))
+    {
+      cif->gptx_flags |= GPTX_FFI_WITH_F;
+    }
+  else
+    {
+      int i;
+      for (i = 0; i < cif->nargs; i++)
+        if (is_f_register_candidate (cif->arg_types[i]))
+          {
+            cif->gptx_flags |= GPTX_FFI_WITH_F;
+            break;
+          }
+    }
+
+  return FFI_OK;
+}
+
+/* Call a function with the provided arguments and capture the return
+   value.  */
+void
+ffi_call (ffi_cif *cif, void (*fn)(void), void *rvalue, void **avalue)
+{
+  extended_cif ecif;
+
+  ecif.cif = cif;
+  ecif.avalue = avalue;
+  ecif.rvalue = rvalue;
+
+  switch (cif->abi)
+    {
+    case FFI_SYSV:
+      {
+        struct call_context context;
+	size_t stack_bytes;
+
+	/* Figure out the total amount of stack space we need, the
+	   above call frame space needs to be 8 bytes aligned to
+	   ensure correct alignment of the first object inserted in
+	   that space hence the ALIGN applied to cif->bytes.*/
+	stack_bytes = ALIGN(cif->bytes, 8);
+
+	memset (&context, 0, sizeof (context));
+        if (is_register_candidate (cif->rtype))
+          {
+            ffi_call_SYSV (gptx_prep_args, &context, &ecif, stack_bytes, fn);
+            switch (cif->rtype->type)
+              {
+              case FFI_TYPE_VOID:
+              case FFI_TYPE_DOUBLE:
+#if FFI_TYPE_DOUBLE != FFI_TYPE_LONGDOUBLE
+              case FFI_TYPE_LONGDOUBLE:
+#endif
+              case FFI_TYPE_UINT8:
+              case FFI_TYPE_SINT8:
+              case FFI_TYPE_UINT16:
+              case FFI_TYPE_SINT16:
+              case FFI_TYPE_UINT32:
+              case FFI_TYPE_SINT32:
+              case FFI_TYPE_POINTER:
+              case FFI_TYPE_UINT64:
+              case FFI_TYPE_INT:
+              case FFI_TYPE_SINT64:
+		{
+		  void *addr = get_basic_type_addr (cif->rtype->type,
+						    &context, 0);
+		  copy_basic_type (rvalue, addr, cif->rtype->type, 0);
+		  break;
+		}
+
+              case FFI_TYPE_FLOAT:
+                {
+                  void *addr = get_basic_type_addr (cif->rtype->type,
+						    &context, 0);
+                  copy_float_type_back (rvalue, addr);
+                  break;
+                }
+
+              case FFI_TYPE_STRUCT:
+                if (is_hfa (cif->rtype))
+		  {
+		    int j;
+		    unsigned short type = get_homogeneous_type (cif->rtype);
+		    unsigned elems = element_count (cif->rtype);
+		    for (j = 0; j < elems; j++)
+		      {
+			void *reg = get_basic_type_addr (type, &context, j);
+                        if (type == FFI_TYPE_FLOAT)
+                          copy_float_type_back (rvalue, reg);
+                        else
+			  copy_basic_type (rvalue, reg, type, 0);
+			rvalue += get_basic_type_size (type);
+		      }
+		  }
+                else if ((cif->rtype->size + 7) / 8 < N_R_ARG_REG)
+                  {
+                    size_t size = ALIGN (cif->rtype->size, sizeof (UINT64));
+                    memcpy (rvalue, get_r_addr (&context, 0), size);
+                  }
+                else
+                  {
+                    FFI_ASSERT (0);
+                  }
+                break;
+
+              default:
+                FFI_ASSERT (0);
+                break;
+              }
+          }
+        else
+          {
+            memcpy (get_r_addr (&context, 0), &rvalue, sizeof (UINT64));
+            ffi_call_SYSV (gptx_prep_args, &context, &ecif,
+			   stack_bytes, fn);
+          }
+        break;
+      }
+
+    default:
+      FFI_ASSERT (0);
+      break;
+    }
+}
+
+static unsigned char trampoline [] =
+{ 0x04, 0x00, 0xc7, 0x12,	/* aaddpci	$a7, 1f	*/
+  0x08, 0x70, 0x31, 0x40,	/* ldut		$t1, $a7, 8	*/
+  //0x00, 0x70, 0x37, 0x32,	/* lda		$a7, $a7	*/
+  0x00, 0x01, 0x40, 0x03	/* j		$t1	*/
+};
+
+/* Build a trampoline.  */
+
+#define FFI_INIT_TRAMPOLINE(TRAMP,FUN,CTX,FLAGS)			\
+  ({unsigned char *__tramp = (unsigned char*)(TRAMP);			\
+    UINT64  __fun = (UINT64)(FUN);					\
+    UINT64  __ctx = (UINT64)(CTX);					\
+    UINT64  __flags = (UINT64)(FLAGS);					\
+    memcpy (__tramp, trampoline, sizeof (trampoline));			\
+    memcpy (__tramp + 16, &__fun, sizeof (__fun));			\
+    memcpy (__tramp + 24, &__ctx, sizeof (__ctx));			\
+    memcpy (__tramp + 32, &__flags, sizeof (__flags));			\
+    ffi_clear_cache(__tramp, __tramp + FFI_TRAMPOLINE_SIZE);		\
+  })
+
+ffi_status
+ffi_prep_closure_loc (ffi_closure* closure,
+                      ffi_cif* cif,
+                      void (*fun)(ffi_cif*,void*,void**,void*),
+                      void *user_data,
+                      void *codeloc)
+{
+  if (cif->abi != FFI_SYSV)
+    return FFI_BAD_ABI;
+
+  FFI_INIT_TRAMPOLINE (&closure->tramp[0], &ffi_closure_SYSV, codeloc,
+		       cif->gptx_flags);
+
+  closure->cif  = cif;
+  closure->user_data = user_data;
+  closure->fun  = fun;
+
+  return FFI_OK;
+}
+
+/* Primary handler to setup and invoke a function within a closure.
+
+   A closure when invoked enters via the assembler wrapper
+   ffi_closure_SYSV(). The wrapper allocates a call context on the
+   stack, saves the interesting registers (from the perspective of
+   the calling convention) into the context then passes control to
+   ffi_closure_SYSV_inner() passing the saved context and a pointer to
+   the stack at the point ffi_closure_SYSV() was invoked.
+
+   On the return path the assembler wrapper will reload call context
+   registers.
+
+   ffi_closure_SYSV_inner() marshalls the call context into ffi value
+   descriptors, invokes the wrapped function, then marshalls the return
+   value back into the call context.  */
+
+void FFI_HIDDEN
+ffi_closure_SYSV_inner (ffi_closure *closure, struct call_context *context,
+			void *stack)
+{
+  ffi_cif *cif = closure->cif;
+  void **avalue = (void**) alloca (cif->nargs * sizeof (void*));
+  void *rvalue = NULL;
+  int i;
+  struct arg_state state;
+  void *single_raw = NULL;
+  int in_stack;
+
+  arg_init (&state, ALIGN(cif->bytes, 16));
+
+  if (!is_register_candidate (cif->rtype))
+    state.ngrn++;
+  for (i = 0; i < cif->nargs; i++)
+    {
+      ffi_type *ty = cif->arg_types[i];
+
+      switch (ty->type)
+	{
+	case FFI_TYPE_VOID:
+	  FFI_ASSERT (0);
+	  break;
+
+	case FFI_TYPE_UINT8:
+	case FFI_TYPE_SINT8:
+	case FFI_TYPE_UINT16:
+	case FFI_TYPE_SINT16:
+	case FFI_TYPE_UINT32:
+	case FFI_TYPE_SINT32:
+	case FFI_TYPE_INT:
+	case FFI_TYPE_POINTER:
+	case FFI_TYPE_UINT64:
+	case FFI_TYPE_SINT64:
+	case FFI_TYPE_DOUBLE:
+#if FFI_TYPE_DOUBLE != FFI_TYPE_LONGDOUBLE
+	case FFI_TYPE_LONGDOUBLE:
+	  avalue[i] = allocate_to_register_or_stack (context, stack,
+						     &state, ty->type, &in_stack);
+	  break;
+#endif
+	case FFI_TYPE_FLOAT:
+          if (state.nfrn >= N_F_ARG_REG)
+       	    avalue[i] = allocate_to_register_or_stack (context, stack,
+						       &state, ty->type, &in_stack);
+	  else
+          {
+	    avalue[i] = alloca(sizeof(float));
+	    single_raw = allocate_to_register_or_stack (context, stack,
+	       &state, ty->type, &in_stack);
+	    __asm__ volatile (
+	      "\tldf\t$f8, %1\n\tstfs\t$f8,%0\n"
+	      : "=m"(*(float *)avalue[i])
+	      : "m"(*(double *)single_raw) : "memory", "$f8");
+          }
+	  break;
+
+	case FFI_TYPE_STRUCT:
+	  if (is_hfa (ty))
+	    {
+	      unsigned n = element_count (ty);
+	      if (available_f (&state) < 
+                  (n << (get_homogeneous_type (ty) == FFI_TYPE_LONGDOUBLE)))
+		{
+		  state.nfrn = N_F_ARG_REG;
+		  avalue[i] = allocate_to_stack (&state, stack, ty->alignment,
+						 ty->size);
+		}
+	      else
+		{
+		  switch (get_homogeneous_type (ty))
+		    {
+		    case FFI_TYPE_FLOAT:
+		      {
+			/* Eeek! We need a pointer to the structure,
+			   however the homogeneous float elements are
+			   being passed in individual S registers,
+			   therefore the structure is not represented as
+			   a contiguous sequence of bytes in our saved
+			   register context. We need to fake up a copy
+			   of the structure laid out in memory
+			   correctly. The fake can be tossed once the
+			   closure function has returned hence alloca()
+			   is sufficient. */
+			int j;
+			UINT32 *p = avalue[i] = alloca (ty->size);
+			for (j = 0; j < element_count (ty); j++)
+			  __asm__ volatile (
+			    "\tldf\t$f8, %1\n\tstfs\t$f8,%0\n"
+			    : "=m"(p[j])
+			    : "m"(*(double *)allocate_to_f (context, &state))
+			    : "memory", "$f8");
+			break;
+		      }
+
+		    case FFI_TYPE_DOUBLE:
+		      {
+			/* Eeek! We need a pointer to the structure,
+			   however the homogeneous float elements are
+			   being passed in individual S registers,
+			   therefore the structure is not represented as
+			   a contiguous sequence of bytes in our saved
+			   register context. We need to fake up a copy
+			   of the structure laid out in memory
+			   correctly. The fake can be tossed once the
+			   closure function has returned hence alloca()
+			   is sufficient. */
+			int j;
+			UINT64 *p = avalue[i] = alloca (ty->size);
+			for (j = 0; j < element_count (ty); j++)
+			  memcpy (&p[j],
+				  allocate_to_f (context, &state),
+				  sizeof (*p));
+			break;
+		      }
+
+#if FFI_TYPE_DOUBLE != FFI_TYPE_LONGDOUBLE
+		    case FFI_TYPE_LONGDOUBLE:
+			  memcpy (&avalue[i],
+				  allocate_to_ld (context, &state),
+				  sizeof (*avalue));
+		      break;
+#endif
+
+		    default:
+		      FFI_ASSERT (0);
+		      break;
+		    }
+		}
+	    }
+	  else if (ty->size > 16)
+	    {
+	      /* Replace Composite type of size greater than 16 with a
+		 pointer.  */
+	      memcpy (&avalue[i],
+		      allocate_to_register_or_stack (context, stack,
+						     &state, FFI_TYPE_POINTER,
+						     &in_stack),
+		      sizeof (avalue[i]));
+	    }
+	  else if (available_r (&state) >= (ty->size + 7) / 8)
+	    {
+	      avalue[i] = get_r_addr (context, state.ngrn);
+	      state.ngrn += (ty->size + 7) / 8;
+	    }
+	  else
+	    {
+	      state.ngrn = N_R_ARG_REG;
+
+	      avalue[i] = allocate_to_stack (&state, stack, ty->alignment,
+					     ty->size);
+	    }
+	  break;
+
+	default:
+	  FFI_ASSERT (0);
+	  break;
+	}
+    }
+
+  if (is_register_candidate (cif->rtype))
+    {
+      /* Register candidates are *always* returned in registers. */
+
+      /* Allocate a scratchpad for the return value, we will let the
+         callee scrible the result into the scratch pad then move the
+         contents into the appropriate return value location for the
+         call convention.  */
+      rvalue = alloca (cif->rtype->size);
+      (closure->fun) (cif, rvalue, avalue, closure->user_data);
+
+      /* Copy the return value into the call context so that it is returned
+         as expected to our caller.  */
+      switch (cif->rtype->type)
+        {
+        case FFI_TYPE_VOID:
+          break;
+
+        case FFI_TYPE_UINT8:
+        case FFI_TYPE_UINT16:
+        case FFI_TYPE_UINT32:
+        case FFI_TYPE_POINTER:
+        case FFI_TYPE_UINT64:
+        case FFI_TYPE_SINT8:
+        case FFI_TYPE_SINT16:
+        case FFI_TYPE_INT:
+        case FFI_TYPE_SINT32:
+        case FFI_TYPE_SINT64:
+        case FFI_TYPE_FLOAT:
+        case FFI_TYPE_DOUBLE:
+#if FFI_TYPE_DOUBLE != FFI_TYPE_LONGDOUBLE
+        case FFI_TYPE_LONGDOUBLE:
+#endif
+	  {
+	    void *addr = get_basic_type_addr (cif->rtype->type, context, 0);
+	    copy_basic_type (addr, rvalue, cif->rtype->type, 0);
+            break;
+	  }
+        case FFI_TYPE_STRUCT:
+          if (is_hfa (cif->rtype))
+	    {
+	      int j;
+	      unsigned short type = get_homogeneous_type (cif->rtype);
+	      unsigned elems = element_count (cif->rtype);
+	      for (j = 0; j < elems; j++)
+		{
+		  void *reg = get_basic_type_addr (type, context, j);
+		  copy_basic_type (reg, rvalue, type, 0);
+		  rvalue += get_basic_type_size (type);
+		}
+	    }
+          else if ((cif->rtype->size + 7) / 8 < N_R_ARG_REG)
+            {
+              size_t size = ALIGN (cif->rtype->size, sizeof (UINT64)) ;
+              memcpy (get_r_addr (context, 0), rvalue, size);
+            }
+          else
+            {
+              FFI_ASSERT (0);
+            }
+          break;
+        default:
+          FFI_ASSERT (0);
+          break;
+        }
+    }
+  else
+    {
+      memcpy (&rvalue, get_r_addr (context, 0), sizeof (UINT64));
+      (closure->fun) (cif, rvalue, avalue, closure->user_data);
+    }
+}
+
diff -Nura output/build/libffi-3.2.1-old/src/gptx/ffitarget.h output/build/libffi-3.2.1/src/gptx/ffitarget.h
--- a/src/gptx/ffitarget.h	1970-01-01 08:00:00.000000000 +0800
+++ b/src/gptx/ffitarget.h	2019-02-21 17:38:06.000000000 +0800
@@ -0,0 +1,59 @@
+/* Copyright (c) 2009, 2010, 2011, 2012 ARM Ltd.
+
+Permission is hereby granted, free of charge, to any person obtaining
+a copy of this software and associated documentation files (the
+``Software''), to deal in the Software without restriction, including
+without limitation the rights to use, copy, modify, merge, publish,
+distribute, sublicense, and/or sell copies of the Software, and to
+permit persons to whom the Software is furnished to do so, subject to
+the following conditions:
+
+The above copyright notice and this permission notice shall be
+included in all copies or substantial portions of the Software.
+
+THE SOFTWARE IS PROVIDED ``AS IS'', WITHOUT WARRANTY OF ANY KIND,
+EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
+MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.
+IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY
+CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT,
+TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE
+SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.  */
+
+#ifndef LIBFFI_TARGET_H
+#define LIBFFI_TARGET_H
+
+#ifndef LIBFFI_H
+#error "Please do not include ffitarget.h directly into your source.  Use ffi.h instead."
+#endif
+
+#ifndef LIBFFI_ASM
+typedef unsigned long ffi_arg;
+typedef signed long ffi_sarg;
+
+typedef enum ffi_abi
+  {
+    FFI_FIRST_ABI = 0,
+    FFI_SYSV,
+    FFI_LAST_ABI,
+    FFI_DEFAULT_ABI = FFI_SYSV
+  } ffi_abi;
+#endif
+
+/* ---- Definitions for closures ----------------------------------------- */
+
+#define FFI_CLOSURES 1
+#define FFI_TRAMPOLINE_SIZE 40
+#define FFI_NATIVE_RAW_API 0
+
+/* ---- Internal ---- */
+
+#define FFI_EXTRA_CIF_FIELDS unsigned gptx_flags
+
+#define GPTX_FFI_WITH_F_BIT 0
+#define GPTX_FFI_WITH_F (1 << GPTX_FFI_WITH_F_BIT)
+
+#define GPTX_N_RREG 32
+#define GPTX_N_FREG 32
+#define GPTX_CALL_CONTEXT_SIZE (GPTX_N_RREG * 8 + GPTX_N_FREG * 8)
+
+#endif
diff -Nura output/build/libffi-3.2.1-old/src/gptx/sysv.S output/build/libffi-3.2.1/src/gptx/sysv.S
--- a/src/gptx/sysv.S	1970-01-01 08:00:00.000000000 +0800
+++ b/src/gptx/sysv.S	2019-02-21 17:38:06.000000000 +0800
@@ -0,0 +1,353 @@
+/* Copyright (c) 2009, 2010, 2011, 2012 ARM Ltd.
+
+Permission is hereby granted, free of charge, to any person obtaining
+a copy of this software and associated documentation files (the
+``Software''), to deal in the Software without restriction, including
+without limitation the rights to use, copy, modify, merge, publish,
+distribute, sublicense, and/or sell copies of the Software, and to
+permit persons to whom the Software is furnished to do so, subject to
+the following conditions:
+
+The above copyright notice and this permission notice shall be
+included in all copies or substantial portions of the Software.
+
+THE SOFTWARE IS PROVIDED ``AS IS'', WITHOUT WARRANTY OF ANY KIND,
+EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
+MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.
+IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY
+CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT,
+TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE
+SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.  */
+
+#define LIBFFI_ASM
+#include <fficonfig.h>
+#include <ffi.h>
+
+#ifdef HAVE_MACHINE_ASM_H
+#include <machine/asm.h>
+#else
+#ifdef __USER_LABEL_PREFIX__
+#define CONCAT1(a, b) CONCAT2(a, b)
+#define CONCAT2(a, b) a ## b
+
+/* Use the right prefix for global labels.  */
+#define CNAME(x) CONCAT1 (__USER_LABEL_PREFIX__, x)
+#else
+#define CNAME(x) x
+#endif
+#endif
+
+#define cfi_adjust_cfa_offset(off)	.cfi_adjust_cfa_offset off
+#define cfi_rel_offset(reg, off)	.cfi_rel_offset reg, off
+#define cfi_offset(reg, off)		.cfi_offset reg, off
+#define cfi_restore(reg)		.cfi_restore reg
+#define cfi_def_cfa_register(reg)	.cfi_def_cfa_register reg
+
+        .text
+        .globl CNAME(ffi_call_SYSV)
+#ifdef __ELF__
+        .type CNAME(ffi_call_SYSV), @function
+#endif
+        .align 5
+
+/* ffi_call_SYSV()
+
+   Create a stack frame, setup an argument context, call the callee
+   and extract the result.
+
+   The maximum required argument stack size is provided,
+   ffi_call_SYSV() allocates that stack space then calls the
+   prepare_fn to populate register context and stack.  The
+   argument passing registers are loaded from the register
+   context and the callee called, on return the register passing
+   register are saved back to the context.  Our caller will
+   extract the return value from the final state of the saved
+   register context.
+
+   Prototype:
+
+   extern unsigned
+   ffi_call_SYSV (void (*)(struct call_context *context, unsigned char *,
+			   extended_cif *),
+                  struct call_context *context,
+                  extended_cif *,
+                  size_t required_stack_size,
+                  void (*fn)(void));
+
+   Therefore on entry we have:
+
+   r8 prepare_fn
+   r9 &context
+   r10 &ecif
+   r11 bytes
+   r12 fn
+
+   This function uses the following stack frame layout:
+
+   ==
+                saved t7(lr)
+   afp(fp)->    saved afp(fp)
+                saved r0
+   asp'   ->    saved a3
+                ...
+   asp    ->    (constructed callee stack arguments)
+   ==
+
+   Voila! */
+
+        .cfi_startproc
+CNAME(ffi_call_SYSV):
+	aaddai	$asp, $asp, -8
+	cfi_adjust_cfa_offset (8)
+	stut	$t7, $asp, -8
+        cfi_offset ($t7, -8)
+	cfi_adjust_cfa_offset (8)
+	sta	$afp, $asp
+        cfi_offset ($a1, -16)
+	aaddai	$afp, $asp, 0
+	cfi_def_cfa_register ($a1)
+	aaddai  $asp, $asp, -8
+        stul    $r0, $asp, -8
+        cfi_rel_offset ($r0, -8)
+        addi    $r0, $r12, 0
+        sta     $a3, $asp
+        cfi_rel_offset ($a3, -16)
+
+        aaddri  $a3, $r9, 0
+
+        /* Allocate the stack space for the actual arguments, many
+           arguments will be passed in registers, but we assume
+           worst case and allocate sufficient stack for ALL of
+           the arguments.  */
+        subfi   $r11, $r11, 0
+        aaddar_b    $asp, $asp, $r11
+
+        /* unsigned (*prepare_fn) (struct call_context *context,
+				   unsigned char *stack, extended_cif *ecif);
+	 */
+        tsetr   $t1, $r8
+        addi    $r8, $r9, 0
+        rseta   $r9, $asp
+        /* $r10 already in place */
+        call    $t1
+        tsetr   $t1, $r0
+
+        /* Preserve the flags returned.  */
+        taddpci $t0, 1f
+        andi    $r0, $r8, 1 << GPTX_FFI_WITH_F_BIT
+
+        /* Figure out if we should touch the floating point registers.  */
+        jci_eq  $t0, $r0, 0
+
+        /* Load the vector argument passing registers.  */
+        aaddai  $a3, $a3, 8*32
+        lduf    $f8, $a3, 8 
+        lduf    $f9, $a3, 8 
+        lduf    $f10, $a3, 8 
+        lduf    $f11, $a3, 8 
+        lduf    $f12, $a3, 8 
+        lduf    $f13, $a3, 8 
+        lduf    $f14, $a3, 8 
+        lduf    $f15, $a3, -8*39 
+1:
+        /* Load the core argument passing registers.  */
+        ldul    $r8, $a3, 8
+        ldul    $r9, $a3, 8
+        ldul    $r10, $a3, 8
+        ldul    $r11, $a3, 8
+        ldul    $r12, $a3, 8
+        ldul    $r13, $a3, 8
+        ldul    $r14, $a3, 8
+        ldul    $r15, $a3, -8*7
+
+        call    $t1
+
+        /* Save the core argument passing registers.  */
+        taddpci $t0, 1f
+        stul    $r8, $a3, 8
+        stul    $r9, $a3, 8
+        stul    $r10, $a3, 8
+        stul    $r11, $a3, 8
+        stul    $r12, $a3, 8
+        stul    $r13, $a3, 8
+        stul    $r14, $a3, 8
+        stul    $r15, $a3, 8*25 
+
+        /* Note nothing useful ever comes back in x8!  */
+
+        /* Figure out if we should touch the vector registers.  */
+        jci_eq  $t0, $r0, 0
+
+        /* Save the vector argument passing registers.  */
+        stuf    $f8, $a3, 8
+        stuf    $f9, $a3, 8
+        stuf    $f10, $a3, 8
+        stuf    $f11, $a3, 8
+        stuf    $f12, $a3, 8
+        stuf    $f13, $a3, 8
+        stuf    $f14, $a3, 8
+        stf     $f15, $a3
+1:
+        /* All done, unwind our stack frame.  */
+	aaddai  $asp, $afp, -16
+        lda     $a3, $asp
+        cfi_restore ($a3)
+        aaddai  $asp, $asp, 8
+        ldul    $r0, $asp, 8
+        cfi_restore ($r0)
+
+	.cfi_def_cfa $a0, 16
+        lda     $afp, $asp
+        cfi_restore ($a1)
+        aaddai  $asp, $asp, 8
+	cfi_adjust_cfa_offset (-8)
+        ldut    $t7, $asp, 8
+        cfi_restore ($t7)
+        .cfi_def_cfa $a0, 0
+
+        ret
+
+        .cfi_endproc
+#ifdef __ELF__
+        .size CNAME(ffi_call_SYSV), .-CNAME(ffi_call_SYSV)
+#endif
+
+/* ffi_closure_SYSV
+
+   Closure invocation glue. This is the low level code invoked directly by
+   the closure trampoline to setup and call a closure.
+
+   On entry a7 points to a struct trampoline_data, t1 has been clobbered
+   all other registers are preserved.
+
+   We allocate a call context and save the argument passing registers,
+   then invoked the generic C ffi_closure_SYSV_inner() function to do all
+   the real work, on return we load the result passing registers back from
+   the call context.
+
+   On entry
+
+   extern void
+   ffi_closure_SYSV (struct trampoline_data *);
+
+   struct trampoline_data
+   {
+        UINT64 *ffi_closure;
+        UINT64 flags;
+   };
+
+   This function uses the following stack frame layout:
+
+   ==
+                saved t7(lr)
+   afp(fp)->    saved afp(fp)
+                saved r0
+                ...
+   sp     ->    call_context
+   ==
+
+   Voila!  */
+
+        .text
+        .globl CNAME(ffi_closure_SYSV)
+        .align 5
+        .cfi_startproc
+CNAME(ffi_closure_SYSV):
+	aaddai	$asp, $asp, -8
+	cfi_adjust_cfa_offset (8)
+	stut	$t7, $asp, -8
+        cfi_offset ($t7, -8)
+	cfi_adjust_cfa_offset (8)
+	sta	$afp, $asp
+        cfi_offset ($a1, -16)
+	aaddai	$afp, $asp, 0
+	cfi_def_cfa_register ($a1)
+	aaddai	$asp, $asp, -8
+
+        stul    $r0, $asp, -8*(25 + 32)
+        cfi_rel_offset ($r0, -8)
+
+        /* Preserve our struct trampoline_data *  */
+        aaddai  $a7, $a7, 8
+
+        /* Save the rest of the argument passing registers.  */
+        /* Figure out if we should touch the floating point registers.  */
+        taddpci $t0, 1f
+        ldul    $r0, $a7, -8
+        andi    $r0, $r0, 1 << GPTX_FFI_WITH_F_BIT
+        jci_eq  $t0, $r0, 0
+
+        /* Save the argument passing floating point registers.  */
+        aaddai  $asp, $asp, 8*32
+        stuf    $f15, $asp, -8
+        stuf    $f14, $asp, -8
+        stuf    $f13, $asp, -8
+        stuf    $f12, $asp, -8
+        stuf    $f11, $asp, -8
+        stuf    $f10, $asp, -8
+        stuf    $f9, $asp, -8
+        stuf    $f8, $asp, -8*25
+1:
+        stul    $r15, $asp, -8
+        stul    $r14, $asp, -8
+        stul    $r13, $asp, -8
+        stul    $r12, $asp, -8
+        stul    $r11, $asp, -8
+        stul    $r10, $asp, -8
+        stul    $r9, $asp, -8
+        stl     $r8, $asp
+
+        /* Load &ffi_closure..  */
+        ldl     $r8, $a7
+        rseta   $r9, $asp
+	taddpcil $t4, CNAME(ffi_closure_SYSV_inner)
+        /* Compute the location of the stack at the point that the
+           trampoline was called.  */
+        rseta   $r10, $afp
+	taddti  $t1, $t4, CNAME(ffi_closure_SYSV_inner) 
+        addi    $r10, $r10, 16
+
+        call    $t1
+        /* Load the result passing core registers.  */
+        ldul    $r8, $asp, 8
+        ldul    $r9, $asp, 8
+        ldul    $r10, $asp, 8
+        ldul    $r11, $asp, 8
+        ldul    $r12, $asp, 8
+        ldul    $r13, $asp, 8
+        ldul    $r14, $asp, 8
+        ldul    $r15, $asp, 8*(25+32)
+        /* Figure out if we should touch the floating point registers.  */
+        taddpci $t0, 1f
+        jci_eq  $t0, $r0, 0
+
+        /* Load the result passing floating point registers.  */
+        aaddai  $asp, $asp, -8*32
+        lduf    $f8, $asp, 8 
+        lduf    $f9, $asp, 8 
+        lduf    $f10, $asp, 8 
+        lduf    $f11, $asp, 8 
+        lduf    $f12, $asp, 8 
+        lduf    $f13, $asp, 8 
+        lduf    $f14, $asp, 8 
+        lduf    $f15, $asp, 8*25
+1:
+
+        /* We are done, unwind our frame.  */
+        ldul    $r0, $asp, 8
+        cfi_restore ($r0)
+
+	.cfi_def_cfa $a0, 16
+        lda     $afp, $asp
+        cfi_restore ($a1)
+        aaddai  $asp, $asp, 8
+	cfi_adjust_cfa_offset (-8)
+        ldut    $t7, $asp, 8
+        cfi_restore ($t7)
+        .cfi_def_cfa $a0, 0
+
+        ret
+        .cfi_endproc
+#ifdef __ELF__
+        .size CNAME(ffi_closure_SYSV), .-CNAME(ffi_closure_SYSV)
+#endif
